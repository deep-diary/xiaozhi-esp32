#include "wifi_board.h"
#include "codecs/es8388_audio_codec.h"
#include "display/lcd_display.h"
#include "application.h"
#include "button.h"
#include "config.h"
#include "i2c_device.h"
#include "led/single_led.h"
#include "led/circular_strip.h"
#include "esp32_camera.h"
#include "mcp_server.h"
#include "gimbal/Gimbal.h"
#include "can/ESP32-TWAI-CAN.hpp"
#include "motor/protocol_motor.h"
#include "motor/deep_motor.h"
#include "led/led_control.h"
#include "motor/deep_motor_control.h"
#include "gimbal/gimbal_control.h"
#include "arm/deep_arm.h"
#include "arm/deep_arm_control.h"
#include "streaming/mjpeg_server.h"
#include "sensor/QMA6100P/qma6100p.h"

#include <esp_log.h>
#include <esp_lcd_panel_vendor.h>
#include <esp_event.h>
#include <esp_wifi.h>
#include <driver/i2c_master.h>
#include <driver/spi_common.h>
#include <wifi_station.h>
#include <cJSON.h>

#define TAG "atk_dnesp32s3"

// æ˜¯å¦å¯ç”¨QMA6100PåŠ é€Ÿåº¦è®¡
#define ENABLE_QMA6100P_FEATURE 1

class XL9555 : public I2cDevice {
public:
    XL9555(i2c_master_bus_handle_t i2c_bus, uint8_t addr) : I2cDevice(i2c_bus, addr) {
        WriteReg(0x06, 0x03);
        WriteReg(0x07, 0xF0);
    }

    void SetOutputState(uint8_t bit, uint8_t level) {
        uint16_t data;
        int index = bit;

        if (bit < 8) {
            data = ReadReg(0x02);
        } else {
            data = ReadReg(0x03);
            index -= 8;
        }

        data = (data & ~(1 << index)) | (level << index);

        if (bit < 8) {
            WriteReg(0x02, data);
        } else {
            WriteReg(0x03, data);
        }
    }
};

class atk_dnesp32s3 : public WifiBoard {
private:
    i2c_master_bus_handle_t i2c_bus_;
    Button boot_button_;
    LcdDisplay* display_;
    XL9555* xl9555_;
    Esp32Camera* camera_;
    Gimbal_t gimbal_;
    
    // CANç›¸å…³æˆå‘˜
    TaskHandle_t can_receive_task_handle_;
    TaskHandle_t arm_status_update_task_handle_;  // æœºæ¢°è‡‚çŠ¶æ€æ›´æ–°ä»»åŠ¡
    DeepMotor* deep_motor_; // æ·±åº¦ç”µæœºç®¡ç†å™¨
    DeepArm* deep_arm_;     // æœºæ¢°è‡‚æ§åˆ¶å™¨
    
    // 2812ç¯å¸¦ç›¸å…³æˆå‘˜
    CircularStrip* led_strip_;
    
    // æ§åˆ¶ç±»æˆå‘˜
    LedStripControl* led_control_;        // LEDæ§åˆ¶
    DeepMotorControl* deep_motor_control_; // ç”µæœºæ§åˆ¶
    // GimbalControl* gimbal_control_;       // ä¸´æ—¶å±è”½èˆµæœºæ§åˆ¶
    // DeepArmControl* deep_arm_control_;      // æœºæ¢°è‡‚MCPæ§åˆ¶
    
    // MJPEGæœåŠ¡å™¨æˆå‘˜
    std::unique_ptr<MjpegServer> mjpeg_server_;
    
    // QMA6100PåŠ é€Ÿåº¦è®¡ç›¸å…³æˆå‘˜
    bool qma6100p_initialized_;
    
    // ç”¨æˆ·ä¸»å¾ªç¯ä»»åŠ¡
    TaskHandle_t user_main_loop_task_handle_;  // ç”¨æˆ·ä¸»å¾ªç¯ä»»åŠ¡å¥æŸ„

    void InitializeI2c() {
        // Initialize I2C peripheral
        i2c_master_bus_config_t i2c_bus_cfg = {
            .i2c_port = (i2c_port_t)I2C_NUM_0,
            .sda_io_num = AUDIO_CODEC_I2C_SDA_PIN,
            .scl_io_num = AUDIO_CODEC_I2C_SCL_PIN,
            .clk_source = I2C_CLK_SRC_DEFAULT,
            .glitch_ignore_cnt = 7,
            .intr_priority = 0,
            .trans_queue_depth = 0,
            .flags = {
                .enable_internal_pullup = 1,
            },
        };
        ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_bus_cfg, &i2c_bus_));

        // Initialize XL9555
        xl9555_ = new XL9555(i2c_bus_, 0x20);
    }

    // Initialize spi peripheral
    void InitializeSpi() {
        spi_bus_config_t buscfg = {};
        buscfg.mosi_io_num = LCD_MOSI_PIN;
        buscfg.miso_io_num = GPIO_NUM_NC;
        buscfg.sclk_io_num = LCD_SCLK_PIN;
        buscfg.quadwp_io_num = GPIO_NUM_NC;
        buscfg.quadhd_io_num = GPIO_NUM_NC;
        buscfg.max_transfer_sz = DISPLAY_WIDTH * DISPLAY_HEIGHT * sizeof(uint16_t);
        ESP_ERROR_CHECK(spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO));
    }

    void InitializeButtons() {
        boot_button_.OnClick([this]() {
            auto& app = Application::GetInstance();
            if (app.GetDeviceState() == kDeviceStateStarting && !WifiStation::GetInstance().IsConnected()) {
                ResetWifiConfiguration();
            }
            app.ToggleChatState();
        });
    }

    void InitializeSt7789Display() {
        esp_lcd_panel_io_handle_t panel_io = nullptr;
        esp_lcd_panel_handle_t panel = nullptr;
        ESP_LOGD(TAG, "Install panel IO");
        // æ¶²æ™¶å±æ§åˆ¶IOåˆå§‹åŒ–
        esp_lcd_panel_io_spi_config_t io_config = {};
        io_config.cs_gpio_num = LCD_CS_PIN;
        io_config.dc_gpio_num = LCD_DC_PIN;
        io_config.spi_mode = 0;
        io_config.pclk_hz = 20 * 1000 * 1000;
        io_config.trans_queue_depth = 7;
        io_config.lcd_cmd_bits = 8;
        io_config.lcd_param_bits = 8;
        esp_lcd_new_panel_io_spi(SPI2_HOST, &io_config, &panel_io);

        // åˆå§‹åŒ–æ¶²æ™¶å±é©±åŠ¨èŠ¯ç‰‡ST7789
        ESP_LOGD(TAG, "Install LCD driver");
        esp_lcd_panel_dev_config_t panel_config = {};
        panel_config.reset_gpio_num = GPIO_NUM_NC;
        panel_config.rgb_ele_order = LCD_RGB_ELEMENT_ORDER_RGB;
        panel_config.bits_per_pixel = 16;
        panel_config.data_endian = LCD_RGB_DATA_ENDIAN_BIG,
        esp_lcd_new_panel_st7789(panel_io, &panel_config, &panel);
        
        esp_lcd_panel_reset(panel);
        xl9555_->SetOutputState(8, 1);
        xl9555_->SetOutputState(2, 0);

        esp_lcd_panel_init(panel);
        esp_lcd_panel_invert_color(panel, DISPLAY_BACKLIGHT_OUTPUT_INVERT);
        esp_lcd_panel_swap_xy(panel, DISPLAY_SWAP_XY); 
        esp_lcd_panel_mirror(panel, DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y);
        display_ = new SpiLcdDisplay(panel_io, panel,
                                    DISPLAY_WIDTH, DISPLAY_HEIGHT, DISPLAY_OFFSET_X, DISPLAY_OFFSET_Y, DISPLAY_MIRROR_X, DISPLAY_MIRROR_Y, DISPLAY_SWAP_XY);
    }

    // åˆå§‹åŒ–æ‘„åƒå¤´ï¼šov2640ï¼›
    // æ ¹æ®æ­£ç‚¹åŸå­å®˜æ–¹ç¤ºä¾‹å‚æ•°
    void InitializeCamera() {
#if ENABLE_CAMERA_FEATURE
        ESP_LOGI(TAG, "åˆå§‹åŒ–ç›¸æœºåŠŸèƒ½...");
        
        xl9555_->SetOutputState(OV_PWDN_IO, 0); // PWDN=ä½ (ä¸Šç”µ)
        vTaskDelay(pdMS_TO_TICKS(100));          // å»¶é•¿ä¸Šç”µå»¶æ—¶
        xl9555_->SetOutputState(OV_RESET_IO, 0); // ç¡®ä¿å¤ä½
        vTaskDelay(pdMS_TO_TICKS(100));          // å»¶é•¿å¤ä½ä¿æŒæ—¶é—´
        xl9555_->SetOutputState(OV_RESET_IO, 1); // é‡Šæ”¾å¤ä½
        vTaskDelay(pdMS_TO_TICKS(200));          // å»¶é•¿å¤ä½é‡Šæ”¾æ—¶é—´

        camera_config_t config = {};

        config.pin_pwdn = CAM_PIN_PWDN;  // å®é™…ç”± XL9555 æ§åˆ¶
        config.pin_reset = CAM_PIN_RESET;// å®é™…ç”± XL9555 æ§åˆ¶
        config.pin_xclk = CAM_PIN_XCLK;
        config.pin_sccb_sda = CAM_PIN_SIOD;
        config.pin_sccb_scl = CAM_PIN_SIOC;

        config.pin_d7 = CAM_PIN_D7;
        config.pin_d6 = CAM_PIN_D6;
        config.pin_d5 = CAM_PIN_D5;
        config.pin_d4 = CAM_PIN_D4;
        config.pin_d3 = CAM_PIN_D3;
        config.pin_d2 = CAM_PIN_D2;
        config.pin_d1 = CAM_PIN_D1;
        config.pin_d0 = CAM_PIN_D0;
        config.pin_vsync = CAM_PIN_VSYNC;
        config.pin_href = CAM_PIN_HREF;
        config.pin_pclk = CAM_PIN_PCLK;

        /* XCLK 10MHz for OV2640 - é™ä½æ—¶é’Ÿé¢‘ç‡æé«˜ç¨³å®šæ€§ */
        config.xclk_freq_hz = 10000000;
        config.ledc_timer = LEDC_TIMER_0;
        config.ledc_channel = LEDC_CHANNEL_0;

        config.pixel_format = PIXFORMAT_RGB565;   /* YUV422,GRAYSCALE,RGB565,JPEG */
        config.frame_size = FRAMESIZE_QVGA;       /* QQVGA-UXGA, For ESP32, do not use sizes above QVGA when not JPEG. The performance of the ESP32-S series has improved a lot, but JPEG mode always gives better frame rates */

        config.jpeg_quality = 12;                 /* 0-63, for OV series camera sensors, lower number means higher quality */
        config.fb_count = 1;                      /* å‡å°‘ç¼“å†²åŒºï¼Œæé«˜ç¨³å®šæ€§ */
        config.fb_location = CAMERA_FB_IN_PSRAM;
        config.grab_mode = CAMERA_GRAB_WHEN_EMPTY;

        esp_err_t err = esp_camera_init(&config); // æµ‹è¯•ç›¸æœºæ˜¯å¦å­˜åœ¨
        if (err != ESP_OK) {
            ESP_LOGE(TAG, "Camera is not plugged in or not supported, error: %s", esp_err_to_name(err));
            // å¦‚æœæ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥ï¼Œè®¾ç½® camera_ ä¸º nullptr
            camera_ = nullptr;
            return;
        }else
        {
            esp_camera_deinit();// é‡Šæ”¾ä¹‹å‰çš„æ‘„åƒå¤´èµ„æº,ä¸ºæ­£ç¡®åˆå§‹åŒ–åšå‡†å¤‡
            camera_ = new Esp32Camera(config);
            ESP_LOGI(TAG, "ç›¸æœºåŠŸèƒ½åˆå§‹åŒ–å®Œæˆ");
        }
#else
        ESP_LOGI(TAG, "ç›¸æœºåŠŸèƒ½å·²ç¦ç”¨");
        camera_ = nullptr;
#endif
    }

    void InitializeGimbal() {
        ESP_LOGI(TAG, "åˆå§‹åŒ–äº‘å°...");
        
        // åˆå§‹åŒ–äº‘å° - æ°´å¹³èˆµæœºGPIO19 (0-270åº¦), å‚ç›´èˆµæœºGPIO20 (0-180åº¦)
        if (Gimbal_init(&gimbal_, SERVO_PAN_GPIO, SERVO_TILT_GPIO) != ESP_OK) {
            ESP_LOGE(TAG, "äº‘å°åˆå§‹åŒ–å¤±è´¥!");
            return;
        }
        
        // è®¾ç½®åˆå§‹ä½ç½®
        Gimbal_setAngles(&gimbal_, 135, 90); // æ°´å¹³èˆµæœº135åº¦(ä¸­é—´), å‚ç›´èˆµæœº90åº¦(ä¸­é—´)
        
        ESP_LOGI(TAG, "äº‘å°åˆå§‹åŒ–å®Œæˆ - PAN: GPIO%d (0-270Â°), TILT: GPIO%d (0-180Â°)", 
                 SERVO_PAN_GPIO, SERVO_TILT_GPIO);
    }

    void InitializeCan() {
#if ENABLE_CAN_FEATURE
        ESP_LOGI(TAG, "åˆå§‹åŒ–CANæ€»çº¿...TX=%d, RX=%d", CAN_TX_GPIO, CAN_RX_GPIO);
        
        // åˆ›å»ºæ·±åº¦ç”µæœºç®¡ç†å™¨ï¼ˆé›†æˆLEDåŠŸèƒ½ï¼‰
        deep_motor_ = new DeepMotor(led_strip_);
        
        // åˆ›å»ºæœºæ¢°è‡‚æ§åˆ¶å™¨ï¼ˆå‡è®¾6ä¸ªç”µæœºIDä¸º1-6ï¼‰
        uint8_t motor_ids[6] = {1, 2, 3, 4, 5, 6};
        deep_arm_ = new DeepArm(deep_motor_, motor_ids);
        
        // åˆå§‹åŒ–CANæ€»çº¿
        if (ESP32Can.begin(ESP32Can.convertSpeed(1000), CAN_TX_GPIO, CAN_RX_GPIO, 10, 10)) {
            ESP_LOGI(TAG, "CANæ€»çº¿å¯åŠ¨æˆåŠŸ! TX=%d, RX=%d, é€Ÿåº¦=1000kbps", CAN_TX_GPIO, CAN_RX_GPIO);
            
            // åˆ›å»ºCANæ¥æ”¶ä»»åŠ¡
            BaseType_t ret = xTaskCreate(can_receive_task, "can_receive", 4096, this, 5, &can_receive_task_handle_);
            if (ret != pdPASS) {
                ESP_LOGE(TAG, "åˆ›å»ºCANæ¥æ”¶ä»»åŠ¡å¤±è´¥!");
            } else {
                ESP_LOGI(TAG, "CANæ¥æ”¶ä»»åŠ¡åˆ›å»ºæˆåŠŸ!");
            }
        } else {
            ESP_LOGE(TAG, "CANæ€»çº¿å¯åŠ¨å¤±è´¥!");
        }
#else
        ESP_LOGI(TAG, "CANæ€»çº¿åŠŸèƒ½å·²ç¦ç”¨");
        deep_motor_ = nullptr;
        deep_arm_ = nullptr;
#endif
    }

    void InitializeWs2812() {
#if ENABLE_LED_STRIP_FEATURE
        ESP_LOGI(TAG, "åˆå§‹åŒ–2812ç¯å¸¦...GPIO=%d, LEDæ•°é‡=%d", WS2812_STRIP_GPIO, WS2812_LED_COUNT);
        
        led_strip_ = new CircularStrip(WS2812_STRIP_GPIO, WS2812_LED_COUNT);
#else
        ESP_LOGI(TAG, "2812ç¯å¸¦åŠŸèƒ½å·²ç¦ç”¨");
        led_strip_ = nullptr;
#endif
    }
    
    void InitializeControls() {
        auto& mcp_server = McpServer::GetInstance();
        (void)mcp_server; // é¿å…æœªä½¿ç”¨å˜é‡è­¦å‘Š
        
        // åˆå§‹åŒ–å„ä¸ªæ§åˆ¶ç±»
#if ENABLE_LED_STRIP_FEATURE
        led_control_ = new LedStripControl(led_strip_, mcp_server);
        ESP_LOGI(TAG, "LEDç¯å¸¦æ§åˆ¶ç±»åˆå§‹åŒ–å®Œæˆ");
#else
        led_control_ = nullptr;
#endif

#if ENABLE_CAN_FEATURE
        deep_motor_control_ = new DeepMotorControl(deep_motor_, mcp_server); // ç”µæœºæ§åˆ¶ï¼ˆLEDå·²é›†æˆåˆ°DeepMotorä¸­ï¼‰
        ESP_LOGI(TAG, "ç”µæœºæ§åˆ¶ç±»åˆå§‹åŒ–å®Œæˆ");
        
        // å¯åŠ¨æœºæ¢°è‡‚çŠ¶æ€æ›´æ–°ä»»åŠ¡
        // BaseType_t ret = xTaskCreate(arm_status_update_task, "arm_status_update", 2048, this, 3, &arm_status_update_task_handle_);
        // if (ret != pdPASS) {
        //     ESP_LOGE(TAG, "åˆ›å»ºæœºæ¢°è‡‚çŠ¶æ€æ›´æ–°ä»»åŠ¡å¤±è´¥!");
        // } else {
        //     ESP_LOGI(TAG, "æœºæ¢°è‡‚çŠ¶æ€æ›´æ–°ä»»åŠ¡åˆ›å»ºæˆåŠŸ!");
        // }
#else
        deep_motor_control_ = nullptr;
#endif

        
        // gimbal_control_ = new GimbalControl(&gimbal_, mcp_server);         // ä¸´æ—¶å±è”½èˆµæœºæ§åˆ¶
        // deep_arm_control_ = new DeepArmControl(deep_arm_, mcp_server, led_strip_);        // æœºæ¢°è‡‚MCPæ§åˆ¶
        
        // åˆå§‹åŒ–MJPEGæœåŠ¡å™¨
#if ENABLE_CAMERA_FEATURE
        InitializeMjpegServer();
#endif
        
        ESP_LOGI(TAG, "æ§åˆ¶ç±»åˆå§‹åŒ–å®Œæˆ");
    }
    
    void InitializeMjpegServer() {
        if (camera_ == nullptr) {
            ESP_LOGI(TAG, "ç›¸æœºæœªåˆå§‹åŒ–ï¼Œè·³è¿‡MJPEGæœåŠ¡å™¨");
            return;
        }
        
        // åˆ›å»ºMJPEGæœåŠ¡å™¨ï¼ˆä¸ç«‹å³å¯åŠ¨ï¼‰
        mjpeg_server_ = std::make_unique<MjpegServer>(8080);  // ç«¯å£8080
        mjpeg_server_->SetFrameRate(10);   // 10fps
        mjpeg_server_->SetJpegQuality(80); // JPEGè´¨é‡80
        
        ESP_LOGI(TAG, "MJPEGæœåŠ¡å™¨å¯¹è±¡åˆ›å»ºå®Œæˆ");
        ESP_LOGI(TAG, "ç­‰å¾…WiFiè¿æ¥åè‡ªåŠ¨å¯åŠ¨æœåŠ¡å™¨...");
        
        ESP_LOGI(TAG, "MJPEGæœåŠ¡å™¨åˆå§‹åŒ–å®Œæˆ");
    }
    
    void InitializeQMA6100P() {
#if ENABLE_QMA6100P_FEATURE
        ESP_LOGI(TAG, "åˆå§‹åŒ–QMA6100PåŠ é€Ÿåº¦è®¡...");
        
        esp_err_t ret = qma6100p_init(i2c_bus_);
        if (ret == ESP_OK) {
            qma6100p_initialized_ = true;
            ESP_LOGI(TAG, "QMA6100PåŠ é€Ÿåº¦è®¡åˆå§‹åŒ–æˆåŠŸ!");
        } else {
            qma6100p_initialized_ = false;
            ESP_LOGW(TAG, "QMA6100PåŠ é€Ÿåº¦è®¡åˆå§‹åŒ–å¤±è´¥ï¼Œå¯èƒ½æœªè¿æ¥ä¼ æ„Ÿå™¨");
        }
#else
        ESP_LOGI(TAG, "QMA6100PåŠ é€Ÿåº¦è®¡åŠŸèƒ½å·²ç¦ç”¨");
        qma6100p_initialized_ = false;
#endif
    }
    
    // ç”¨æˆ·ä¸»å¾ªç¯ä»»åŠ¡ - å¤„ç†å‘¨æœŸæ€§çš„ä¸šåŠ¡é€»è¾‘
    static void user_main_loop_task(void *pvParameters) {
        atk_dnesp32s3* board = static_cast<atk_dnesp32s3*>(pvParameters);
        
        ESP_LOGI(TAG, "ç”¨æˆ·ä¸»å¾ªç¯ä»»åŠ¡å¯åŠ¨");
        
        qma6100p_rawdata_t accel_data;
        uint8_t update_counter = 0;
        char msg_buffer[256];
        
        while (1) {  // ç”¨æˆ·ä¸»å¾ªç¯
            vTaskDelay(pdMS_TO_TICKS(10)); // 10mså»¶è¿Ÿ
            update_counter++;
            
            // ========== åŠ é€Ÿåº¦è®¡æ•°æ®é‡‡é›†å’Œæ˜¾ç¤º ==========
            if (update_counter >= 20 && board->qma6100p_initialized_) {  // æ¯200msæ›´æ–°ä¸€æ¬¡
                update_counter = 0;
                
                // è¯»å–åŠ é€Ÿåº¦è®¡æ•°æ®
                qma6100p_read_rawdata(&accel_data);
                
                // æ ¼å¼åŒ–æ˜¾ç¤ºæ–‡æœ¬
                snprintf(msg_buffer, sizeof(msg_buffer),
                         "ğŸ”„ åŠ é€Ÿåº¦è®¡æ•°æ®:\n"
                         "ACC_X: %.2f m/sÂ²\n"
                         "ACC_Y: %.2f m/sÂ²\n"
                         "ACC_Z: %.2f m/sÂ²\n"
                         "ä¿¯ä»°è§’: %.1fÂ°\n"
                         "ç¿»æ»šè§’: %.1fÂ°",
                         accel_data.acc_x,
                         accel_data.acc_y,
                         accel_data.acc_z,
                         accel_data.pitch,
                         accel_data.roll);
                
                // åœ¨å±å¹•ä¸Šæ˜¾ç¤ºæ•°æ®
                if (board->display_ != nullptr) {
                    board->display_->SetChatMessage("system", msg_buffer);
                }
                
                // åŒæ—¶æ‰“å°åˆ°æ—¥å¿—ï¼ˆæ¯æ¬¡éƒ½æ‰“å°ï¼Œæ–¹ä¾¿è°ƒè¯•ï¼‰
                ESP_LOGI(TAG, "ACC[%.2f, %.2f, %.2f] Pitch:%.1fÂ° Roll:%.1fÂ°", 
                         accel_data.acc_x, accel_data.acc_y, accel_data.acc_z,
                         accel_data.pitch, accel_data.roll);
            }
            
            // ========== åœ¨è¿™é‡Œæ·»åŠ å…¶ä»–å‘¨æœŸæ€§ä»»åŠ¡ ==========
            // ä¾‹å¦‚ï¼šå…¶ä»–ä¼ æ„Ÿå™¨è¯»å–ã€çŠ¶æ€æ£€æŸ¥ã€å®šæ—¶æ“ä½œç­‰
            
        }
    }
    
    void StartMjpegServerWhenReady() {
        if (mjpeg_server_ == nullptr) {
            ESP_LOGW(TAG, "MJPEGæœåŠ¡å™¨å¯¹è±¡æœªåˆ›å»º");
            return;
        }
        
        if (mjpeg_server_->IsRunning()) {
            ESP_LOGI(TAG, "MJPEGæœåŠ¡å™¨å·²åœ¨è¿è¡Œ");
            return;
        }
        
        ESP_LOGI(TAG, "WiFiå·²è¿æ¥ï¼Œå¯åŠ¨MJPEGæœåŠ¡å™¨...");
        
        // å»¶è¿Ÿä¸€ä¸‹ï¼Œç¡®ä¿ç½‘ç»œæ ˆå®Œå…¨å°±ç»ª
        vTaskDelay(pdMS_TO_TICKS(2000));
        
        if (mjpeg_server_->Start()) {
            ESP_LOGI(TAG, "MJPEGæœåŠ¡å™¨å¯åŠ¨æˆåŠŸ");
            ESP_LOGI(TAG, "è®¿é—®åœ°å€: %s", mjpeg_server_->GetUrl().c_str());
            ESP_LOGI(TAG, "å¯é€šè¿‡VLCã€æµè§ˆå™¨æˆ–ffmpegç›´æ¥è®¿é—®è§†é¢‘æµ");
        } else {
            ESP_LOGE(TAG, "MJPEGæœåŠ¡å™¨å¯åŠ¨å¤±è´¥");
        }
    }
    
    // æœºæ¢°è‡‚çŠ¶æ€æ›´æ–°ä»»åŠ¡
    static void arm_status_update_task(void *pvParameters) {
        atk_dnesp32s3* board = static_cast<atk_dnesp32s3*>(pvParameters);
        (void)board; // é¿å…æœªä½¿ç”¨å˜é‡è­¦å‘Š
        
        while (1) {
            // if (board->deep_arm_control_) {
            //     board->deep_arm_control_->UpdateArmStatus();
            // }
            vTaskDelay(pdMS_TO_TICKS(500)); // æ¯500msæ›´æ–°ä¸€æ¬¡çŠ¶æ€
        }
    }

    // CANæ¥æ”¶ä»»åŠ¡
    static void can_receive_task(void *pvParameters) {
        atk_dnesp32s3* board = static_cast<atk_dnesp32s3*>(pvParameters);
        CanFrame rxFrame;
        
        ESP_LOGI(TAG, "CANæ¥æ”¶ä»»åŠ¡å¯åŠ¨");
        
        while(1) {
            if(ESP32Can.readFrame(rxFrame, 1000)) {
                // if(rxFrame.extd) {
                //     ESP_LOGI(TAG, "æ¥æ”¶åˆ°æ‰©å±•å¸§: ID=0x%08lX, é•¿åº¦=%d, æ•°æ®=[", 
                //            rxFrame.identifier, rxFrame.data_length_code);
                // } else {
                //     ESP_LOGI(TAG, "æ¥æ”¶åˆ°æ ‡å‡†å¸§: ID=0x%03lX, é•¿åº¦=%d, æ•°æ®=[", 
                //            rxFrame.identifier, rxFrame.data_length_code);
                // }
                
                // for(int i = 0; i < rxFrame.data_length_code; i++) {
                //     ESP_LOGI(TAG, "%02X", rxFrame.data[i]);
                //     if(i < rxFrame.data_length_code - 1) ESP_LOGI(TAG, " ");
                // }
                // ESP_LOGI(TAG, "]");
                
                // å¤„ç†ç”µæœºåé¦ˆå¸§ï¼ˆé€šè¿‡DeepMotorï¼‰
                if (board->deep_motor_ && board->deep_motor_->processCanFrame(rxFrame)) {
                    // ç”µæœºåé¦ˆå¸§å·²ç”±DeepMotorå¤„ç†
                }
                // å¤„ç†èˆµæœºæ§åˆ¶æŒ‡ä»¤
                else if(rxFrame.identifier == CAN_CMD_SERVO_CONTROL) {
                    Gimbal_handleCanCommand(&board->gimbal_, &rxFrame);
                }
            }
            
            vTaskDelay(10 / portTICK_PERIOD_MS); // 10mså»¶è¿Ÿ
        }
    }

        
        


public:
    atk_dnesp32s3() : boot_button_(BOOT_BUTTON_GPIO, false), 
                      can_receive_task_handle_(nullptr), 
                      arm_status_update_task_handle_(nullptr), 
                      deep_motor_(nullptr), 
                      deep_arm_(nullptr), 
                      led_strip_(nullptr),
                      qma6100p_initialized_(false),
                      user_main_loop_task_handle_(nullptr) {
        InitializeI2c();
        InitializeSpi();
        InitializeSt7789Display();
        InitializeButtons();
        InitializeCamera();
        InitializeGimbal();
        
#if ENABLE_CAN_FEATURE || ENABLE_LED_STRIP_FEATURE
        InitializeWs2812();  // å…ˆåˆå§‹åŒ–2812ç¯å¸¦ï¼ˆDeepMotoréœ€è¦ä½¿ç”¨ï¼‰
        InitializeCan();     // å†åˆå§‹åŒ–CANå’ŒDeepMotorï¼ˆä½¿ç”¨led_strip_ï¼‰
#endif
        InitializeControls(); // åˆå§‹åŒ–æ‰€æœ‰æ§åˆ¶ç±»
        
        // åˆå§‹åŒ–QMA6100PåŠ é€Ÿåº¦è®¡
        InitializeQMA6100P();
        
        // å¯åŠ¨ç”¨æˆ·ä¸»å¾ªç¯ä»»åŠ¡
        BaseType_t ret = xTaskCreate(
            user_main_loop_task,
            "user_main_loop",     // ä»»åŠ¡åç§°
            8192,                 // æ ˆå¤§å°ï¼ˆ8KBï¼Œé¢„ç•™è¶³å¤Ÿç©ºé—´ç”¨äºæ‰©å±•ï¼‰
            this,                 // å‚æ•°ï¼ˆä¼ é€’thisæŒ‡é’ˆï¼‰
            4,                    // ä¼˜å…ˆçº§ï¼ˆä»‹äºç³»ç»Ÿä»»åŠ¡å’Œå®æ—¶ä»»åŠ¡ä¹‹é—´ï¼‰
            &user_main_loop_task_handle_
        );
        
        if (ret != pdPASS) {
            ESP_LOGE(TAG, "åˆ›å»ºç”¨æˆ·ä¸»å¾ªç¯ä»»åŠ¡å¤±è´¥!");
        } else {
            ESP_LOGI(TAG, "ç”¨æˆ·ä¸»å¾ªç¯ä»»åŠ¡åˆ›å»ºæˆåŠŸ!");
        }
    }

    ~atk_dnesp32s3() {
        // åˆ é™¤ç”¨æˆ·ä¸»å¾ªç¯ä»»åŠ¡
        if (user_main_loop_task_handle_ != nullptr) {
            vTaskDelete(user_main_loop_task_handle_);
        }
        // åˆ é™¤CANæ¥æ”¶ä»»åŠ¡
        if (can_receive_task_handle_ != nullptr) {
            vTaskDelete(can_receive_task_handle_);
        }
        // åˆ é™¤æœºæ¢°è‡‚çŠ¶æ€æ›´æ–°ä»»åŠ¡
        if (arm_status_update_task_handle_ != nullptr) {
            vTaskDelete(arm_status_update_task_handle_);
        }
        
        // åˆ é™¤æ§åˆ¶ç±»
        if (led_control_ != nullptr) {
            delete led_control_;
        }
        if (deep_motor_control_ != nullptr) {
            delete deep_motor_control_;
        }
        // if (gimbal_control_ != nullptr) {
        //     delete gimbal_control_;
        // }
        // if (deep_arm_control_ != nullptr) {
        //     delete deep_arm_control_;
        // }
        
        // åˆ é™¤æœºæ¢°è‡‚æ§åˆ¶å™¨
        if (deep_arm_ != nullptr) {
            delete deep_arm_;
        }
        // åˆ é™¤æ·±åº¦ç”µæœºç®¡ç†å™¨
        if (deep_motor_ != nullptr) {
            delete deep_motor_;
        }
        // åˆ é™¤2812ç¯å¸¦
        if (led_strip_ != nullptr) {
            delete led_strip_;
        }
        Gimbal_deinit(&gimbal_);
    }

    virtual Led* GetLed() override {
        static SingleLed led(BUILTIN_LED_GPIO);
        return &led;
    }

    virtual void StartNetwork() override {
        // æ³¨å†ŒWiFiäº‹ä»¶å¤„ç†å™¨ï¼Œåœ¨è¿æ¥æˆåŠŸåå¯åŠ¨MJPEGæœåŠ¡å™¨
        esp_event_handler_register(WIFI_EVENT, WIFI_EVENT_STA_CONNECTED,
            [](void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) {
                auto* board = static_cast<atk_dnesp32s3*>(arg);
                // åˆ›å»ºä¸€ä¸ªå»¶è¿Ÿä»»åŠ¡æ¥å¯åŠ¨MJPEGæœåŠ¡å™¨
                xTaskCreate(
                    [](void* pvParameters) {
                        auto* board = static_cast<atk_dnesp32s3*>(pvParameters);
                        board->StartMjpegServerWhenReady();
                        vTaskDelete(NULL);
                    },
                    "mjpeg_starter",
                    8192,  // 8KBæ ˆç©ºé—´
                    board,
                    5,
                    nullptr
                );
            },
            this
        );
        
        // è°ƒç”¨çˆ¶ç±»çš„ç½‘ç»œå¯åŠ¨æ–¹æ³•
        WifiBoard::StartNetwork();
    }

    virtual AudioCodec* GetAudioCodec() override {
        static Es8388AudioCodec audio_codec(
            i2c_bus_, 
            I2C_NUM_0, 
            AUDIO_INPUT_SAMPLE_RATE, 
            AUDIO_OUTPUT_SAMPLE_RATE,
            AUDIO_I2S_GPIO_MCLK, 
            AUDIO_I2S_GPIO_BCLK, 
            AUDIO_I2S_GPIO_WS, 
            AUDIO_I2S_GPIO_DOUT, 
            AUDIO_I2S_GPIO_DIN,
            GPIO_NUM_NC, 
            AUDIO_CODEC_ES8388_ADDR
        );
        return &audio_codec;
    }

    virtual Display* GetDisplay() override {
        return display_;
    }
    
    virtual Camera* GetCamera() override {
        return camera_;
    }
};

DECLARE_BOARD(atk_dnesp32s3);
